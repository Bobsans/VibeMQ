# Настройка версионирования

**Описание:** Унифицировать версионирование проектов (SemVer), синхронизировать версии между пакетами. Версия задаётся тегом репозитория; автоинкремент отключён.

## ✅ Статус реализации

**Реализовано:** 19 февраля 2026 (обновлено: версия только из тега, без автоинкремента)

**Выполнено:**
- ✅ Версия задаётся тегом репозитория (SemVer: vMajor.Minor.Patch)
- ✅ В release workflow версия из тега передаётся в сборку напрямую через `-p:Version=...` (файла версии в репозитории нет)
- ✅ Все проекты получают версию через `Directory.Build.props` (из свойства MSBuild или fallback 1.0.0)
- ✅ Локальная сборка: по умолчанию 1.0.0; при необходимости — `dotnet build -p:Version=1.2.3`

**Проверка версии в релизе:** версия берётся из тега в [release workflow](.github/workflows/release.yml) (шаг "Get version from tag").

## Требования к версионированию

1. **Автоматический инкремент build версии** — каждый билд должен получать уникальный номер сборки
2. **Инкремент минорной версии при разработке нового функционала** — при работе над новой функциональностью версия должна автоматически увеличиваться
3. **Централизованное управление** — все проекты используют одну версию из одного места
4. **SemVer 2.0** — формат версий должен соответствовать стандарту

## Выбранный подход: версия из тега репозитория

**Преимущества:**
- Версия задаётся только тегом (например, `v1.0.0`); файла версии в репозитории нет
- В release workflow версия из тега передаётся в MSBuild как `-p:Version=...`
- Поддержка SemVer (Major.Minor.Patch)
- Релиз: push тега → workflow передаёт версию в restore/build/pack → публикация

**Файлы:** `Directory.Build.props` (fallback 1.0.0), [release.yml](.github/workflows/release.yml) (версия из тега)

**Детальный план:**

## Шаг 1: Версия из тега в пайплайне
**Файлы:** `Directory.Build.props`, `.github/workflows/release.yml`

**Задачи:**
1. В `Directory.Build.props`: версия из свойства MSBuild `Version`, если не задано — `1.0.0`.
2. В release workflow: извлечь версию из тега (например, `v1.0.0` → `1.0.0`) и передавать в restore/build/pack как `-p:Version=...` и `-p:PackageVersion=...`.
3. Файла версии в репозитории нет — версия задаётся только тегом и пайплайном.

## Шаг 2: Настройка автоматического инкремента минорной версии
**Файл:** `version.json`

**Задачи:**
1. Настроить стратегию инкремента версии:
   - **Feature ветки** (`feature/*`, `feat/*`): автоматический инкремент минорной версии
   - **Main ветка**: стабильная версия без инкремента
   - **Develop ветка**: pre-release версия с инкрементом build
2. Пример конфигурации:
   ```json
   {
     "version": "1.0",
     "publicReleaseRefSpec": [
       "^refs/heads/main$",
       "^refs/tags/v\\d+\\.\\d+(\\.\\d+)?$"
     ],
     "cloudBuild": {
       "buildNumber": {
         "enabled": true
       }
     },
     "release": {
       "branchName": "v{version}",
       "versionIncrement": "minor"
     }
   }
   ```
   
   **Примечание:** Nerdbank.GitVersioning не поддерживает поле `branches` в `version.json`. Версионирование основано на git тегах и количестве коммитов, а не на именах веток. Для настройки версионирования для разных веток можно использовать разные `version.json` файлы в разных ветках или управлять версиями через git теги.

## Шаг 3: Централизованное управление версиями
**Файл:** `Directory.Build.props`

**Задачи:**
1. Удалить ручное управление версиями (если есть)
2. Nerdbank.GitVersioning автоматически установит версии для всех проектов
3. Убедиться что все проекты наследуют версию из `Directory.Build.props`
4. Настроить `AssemblyVersion` и `FileVersion` (опционально, если нужна фиксированная версия сборки)

## Шаг 4: Настройка версий для NuGet пакетов
**Файл:** `Directory.Build.props`

**Задачи:**
1. Nerdbank.GitVersioning автоматически установит `PackageVersion`
2. Убедиться что все проекты используют одну версию
3. Для NuGet пакетов версия будет автоматически синхронизирована

## Шаг 5: Интеграция с CI/CD (опционально)
**Файл:** `.github/workflows/ci.yml` или аналогичный

**Задачи:**
1. В CI/CD Nerdbank.GitVersioning работает автоматически
2. Можно использовать переменные окружения для переопределения версии при необходимости
3. Для GitHub Actions можно использовать `GITHUB_RUN_NUMBER` для build number

## Шаг 6: Настройка генерации changelog
**Файл:** `.github/workflows/changelog.yml` (или аналогичный)

**Задачи:**
1. Выбрать инструмент: `git-cliff`, `conventional-changelog`, или ручной формат
2. Настроить автоматическую генерацию из git commits
3. Формат: `CHANGELOG.md` или `docs/changelog.rst`
4. Интегрировать с процессом релиза

## Шаг 7: Документация процесса версионирования
**Документ:** `docs/docs/versioning.rst`

**Задачи:**
1. Описать процесс версионирования
2. Правила для major/minor/patch версий:
   - **MAJOR** — несовместимые изменения API (ручной инкремент через тег)
   - **MINOR** — новая функциональность (автоматически в feature ветках)
   - **PATCH/BUILD** — исправления багов (автоматически инкрементируется)
3. Процесс релиза:
   - Создание тега `v1.0.0` для стабильного релиза
   - Автоматическая генерация changelog
   - Публикация на NuGet

## Примеры версий

- `1.0.42` — стабильная версия на main ветке (42 коммита после тега v1.0)
- `1.1.15-feature.new-auth` — разработка новой функциональности в ветке `feature/new-auth`
- `1.0.50-dev` — разработка в ветке `develop`
- `1.0.0` — релизная версия (из тега `v1.0.0`)

## Рабочий процесс

1. **Разработка новой функциональности:**
   - Создать ветку `feature/new-feature` или `feat/new-feature`
   - Версия автоматически станет `1.1.{height}-feature.new-feature`
   - При каждом коммите build number инкрементируется

2. **Релиз:**
   - Создать тег `v1.1.0` для нового минорного релиза
   - Версия автоматически станет `1.1.0`
   - CI/CD соберет и опубликует пакеты

3. **Исправление багов:**
   - Работа в `main` или `hotfix/*` ветке
   - Версия будет `1.0.{height}` (patch инкрементируется автоматически)

