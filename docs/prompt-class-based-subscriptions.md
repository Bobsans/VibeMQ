# Промпт: реализация class-based подписок в VibeMQ

Используй этот промпт для реализации подписок на очереди через классы-обработчики (class-based handlers) вместо передачи `Func<T, Task>` в `SubscribeAsync`.

---

## Контекст проекта

- **Клиент**: [VibeMQ.Client](src/VibeMQ.Client) — сейчас подписка делается так:  
  `SubscribeAsync<T>(string queueName, Func<T, Task> handler)`.  
  Обработчики хранятся в `_subscriptionHandlers` как делегаты по имени очереди ([VibeMQClient.cs](src/VibeMQ.Client/VibeMQClient.cs)).
- **DI**: [VibeMQ.Client.DependencyInjection](src/VibeMQ.Client.DependencyInjection) — регистрируется `IVibeMQClientFactory` и настройки; клиент создаётся через `factory.CreateAsync()` ([ServiceCollectionExtensions.cs](src/VibeMQ.Client.DependencyInjection/ServiceCollectionExtensions.cs), [IVibeMQClientFactory.cs](src/VibeMQ.Client.DependencyInjection/IVibeMQClientFactory.cs)).
- **Пример использования**: в [VibeMQ.Example.Client.DI](examples/VibeMQ.Example.Client.DI/Program.cs) подписка и обработка делаются вручную: создаётся клиент, вызывается `SubscribeAsync<Notification>("notifications", notification => { ... })`.

---

## Цель

Ввести **class-based подписки**: обработчики сообщений — это классы (например, реализующие `IMessageHandler<T>`), а не лямбды. Очередь задаётся атрибутом, конвенцией или конфигурацией. Обработчики регистрируются в DI; при старте приложения (или при создании клиента) все зарегистрированные обработчики автоматически подписываются на соответствующие очереди.

---

## Требования к реализации

1. **Интерфейс обработчика**
   - Ввести интерфейс вроде `IMessageHandler<T>` с методом `Task HandleAsync(T message, CancellationToken cancellationToken = default)`.
   - Разрешить опциональную передачу `CancellationToken` в существующий пайплайн (если сейчас в обработчик не передаётся — добавить по желанию).

2. **Привязка к очереди**
   - Определить способ указания имени очереди для обработчика:
     - **Вариант A**: атрибут на классе, например `[Queue("notifications")]`.
     - **Вариант B**: явный контракт, например интерфейс `IHandleQueue<T>` с свойством `string QueueName`.
     - **Вариант C**: конвенция по имени типа (например, `NotificationHandler` → очередь `notifications`).
   - Выбери один основной способ (рекомендуется атрибут или явное свойство) и опиши в коде/документации.

3. **Регистрация в DI**
   - Добавить в пакет **VibeMQ.Client.DependencyInjection** (или новый пакет, если не хочешь смешивать с текущим):
     - Метод расширения для регистрации обработчиков, например:
       - `AddVibeMQMessageHandlers(Assembly?)` — сканирование сборки и регистрация всех классов, реализующих `IMessageHandler<>` и помеченных очередью;
       - и/или `AddVibeMQMessageHandler<THandler>()` для ручной регистрации.
     - Обработчики должны регистрироваться так, чтобы для каждого сообщения можно было разрешить обработчик из контейнера (например, как Scoped или Transient, в зависимости от желаемой семантики жизненного цикла).

4. **Автоподписка при старте**
   - Реализовать механизм, который при появлении подключённого клиента подписывает все зарегистрированные обработчики на свои очереди:
     - **Вариант A**: hosted service, который при старте получает `IVibeMQClientFactory`, создаёт клиент, находит все зарегистрированные `IMessageHandler<>` (через отдельный сервис/коллекцию дескрипторов), для каждой пары (очередь, тип сообщения) вызывает `client.SubscribeAsync<T>(queueName, handler => resolvedHandler.HandleAsync(handler, ct))`, и хранит подписки до остановки приложения.
     - **Вариант B**: расширение на `IHost` / middleware, которое выполняет ту же логику при первом создании клиента.
   - При вызове `SubscribeAsync` под капотом должен вызываться не делегат из лямбды, а разрешённый из DI экземпляр `IMessageHandler<T>` (через фабрику или scope на сообщение), чтобы в обработчике можно было использовать инжектированные зависимости.

5. **Обратная совместимость**
   - Текущий API `SubscribeAsync<T>(string queueName, Func<T, Task> handler)` не удалять: оставить для сценариев без DI и для ручных подписок. Class-based подписки — дополнительный слой поверх него или рядом с ним.

6. **Пример**
   - Добавить или обновить пример (например, [VibeMQ.Example.Client.DI](examples/VibeMQ.Example.Client.DI)):
     - Класс `NotificationHandler : IMessageHandler<Notification>` с привязкой к очереди `notifications`.
     - В `Program.cs` — регистрация обработчиков через новые методы расширения и (при использовании hosted service) без явного вызова `SubscribeAsync` в коде пользователя; при необходимости показать, как запускать клиент и публикацию сообщений для проверки.

7. **Сборки и зависимости**
   - Код обработчиков и атрибутов разместить в [VibeMQ.Client](src/VibeMQ.Client) или в [VibeMQ.Client.DependencyInjection](src/VibeMQ.Client.DependencyInjection), без лишних зависимостей от серверной части. Если вынесешь в отдельный пакет (например, VibeMQ.Client.Handlers), опиши в промпте/README назначение пакета.

8. **Комментарии и стиль**
   - Комментарии в коде — на английском; сообщения пользователю и документация — по желанию на русском или английском (в этом репозитории принято общаться на русском).

---

## Критерии готовности

- Есть интерфейс типа `IMessageHandler<T>` и способ привязки обработчика к очереди (атрибут/контракт/конвенция).
- В DI можно зарегистрировать классы-обработчики и при старте (или при создании клиента) все они автоматически подписываются на свои очереди через один подключённый клиент.
- Для каждого сообщения вызывается экземпляр обработчика, разрешённый из DI (с поддержкой scoped-зависимостей, если выбран scope на сообщение).
- Существующий API `SubscribeAsync<T>(queueName, Func<T, Task>)` сохранён и по-прежнему работает.
- В примере (Client.DI или отдельном) показана полная цепочка: регистрация обработчиков → запуск хоста → получение сообщений классом-обработчиком.

После реализации добавь краткое описание в README или в документацию: как зарегистрировать обработчики и как задаётся очередь для класса.
